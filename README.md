# MusicLAB
Audio Workstation that allows user to record, edit recordings, and apply various effects to the recordings.
## Application :
MusicLAB is an app in MATLAB that works as a digital audio workstation for both Mac and Windows users, enabling users to create music, such as a song or soundtrack. The soundtrack creation system allows users to create multiple tracks, such as Vocals, Guitar, Piano, and/or Drums and also allows users to apply various effects. These effects include Reverse, Tremolo, Echo, Reverb, Slow-Mo, and Chipmunks. MusicLAB can record and play back multiple tracks of audio. MusicLAB can also save multiple tracks into one file.
## Purpose :
The purpose of MusicLAB is to allow users to create music, such as a song or soundtrack while trying to make it user friendly as possible. We wanted to make producing a soundtrack as easy as clicking a button. Our intent was to have anyone use this application even if they do not know how to code.
## Functionality :
The functionality of MusicLAB is based off of the implementation of various MATLAB functions, such as Object Oriented Programming, Graphical User Interface, and Java Interfaces and classes. Our software uses Object-Oriented Design in MATLAB to define classes that describe Recording objects that our application uses. A Graphical User Interface is produced to allow the user to perform multiple functions to edit and produce a soundtrack. The software also uses interfaces and classes from Java to perform certain functions.
# Description of the classes (properties, methods, events) : 
## Project handle class:
 Project  is a handle class that creates all the necessary  Recording objects for the user to save up to four raw recordings and up to four recordings with effects applied. Thus, the constructor creates 8 Recording objects named appropriately to distinguish between raw and edited, and suggest the use for each (i.e. Guitar/Piano and Drums). After a Project has been initiated, the  runUI(Project) method will build the whole GUI. The runUI method contains all of the events and button callback functions to record, edit, play, and save recordings.
## Recording handle class:
Recording is a handle class with properties  Rec, Data,  and  Effects. The constructor creates a MATLAB  audiorecorder object stored in the Rec property. The Data property is defined either after a recording is taken or after an effect is applied by the user through the UI. For raw recordings, the Effect property will be empty, while for a recording with effects applied, Effect will store an Effects object of a specific type (see Child classes of Effects).
## Effects handle class:
 Effects is a handle class with properties  FXData and its only method is the constructor. FXData is a double that stores the data of the  incoming audio signal, which is the raw data upon the first instance of applying an effect. This allows the child classes with specific effects apply the necessary modifications to the incoming data and produce new data.
## Child classes of Effects:
Each child class of the Effects handle class has no properties and each has static methods that contain the constructor and a unique  apply(data)  function. The apply method takes in a double array, data , containing the Data of a Recording object, and outputs  newdata , a double array containing Data of a separate Recording object. The apply method is unique to each child class but in general is a mathematical function that saves the modified input data as new data while keeping the data before the effect was applied. This allows the user to clear unwanted effects and retrieve the raw recording. The respective  apply  functions are as follows:
### Reverse:  
reverses the recording by applying the MATLAB function  flip , which simply flips the order of the elements in  data . This effect, given a melodic recording input, can make interesting ambient sounds or used to mimic the quality of a string orchestra, especially combined with Reverb.
### Tremolo:  
creates a vector of sinusoidal data with customizable initial value, amplitude, and frequency. This vector is concatenated with itself to create an array, called sin_vol, the same size as  data.  The array sin_vol contains values between 0 and 1 and represents the intensity or ‘volume’. Thus, dot-multiplying this array with the original data produces the ‘tremolo’ effect of a wavering sound with oscillating volume (think quickly twisting a volume knob back and forth). Thus, modifying the parameters of the sin wave can modify the depth and speed of the volume change.
### Echo:  
creates copies of the original data, each shifted by an increasing delay amount, and multiplied by a scaling factor (this creates echoes that decay in volume). The arrays are padded in order to be added together, creating the new data with the echo effect. The delay amount and decay factor can be adjusted by the user.
### Reverb: 
also creates padded copies of original data, each with increasing delay, and adds them together. To mimic reverb, or the sound of being in a ‘big hall’, we want the hypothetical sound waves to have a slight delay as they bounce of the walls and quickly decrease in volume as they do so. Thus, the delay is shorter and there are more copies of the data in comparison to Echo, and produces a fuller sound.
### Slow-Mo:  
uses the MATLAB function  resample , which resamples the values  data  at 3/2 (a/b) times the original sample rate. The larger ratio of a/b corresponds to a slower effect and can be customized by the user. This effect will make the audio sound like it is in slow-motion.
### Chipmunks (or Fast-Forward):  
also uses the MATLAB function  resample , but with a new sample rate of 1/2 times the original sample rate. The smaller ratio of a/b corresponds to a faster effect and can be customized.
## Volume handle class:
Volume is a class that uses the java package javax.sound.sampled in order to access the audio ports on the computer being used. This java package  provides interfaces and classes for capture, processing, and playback of sampled audio data. This package is used specifically to access the AudioSystem class which can access various mixers installed on your system. The method  findPort loops over the systems mixers to find the audio output port. The method  OpenLine opens the port’s line object that was found. The method  findVolumeControl loops over the controls of the line object and finds the volume controller. The method  setVolume(value) sets the volume based off of a value given. The getVolume  method returns the current value of the volume controller.
## Implementation details :
The implementation of this application is all GUI based, meaning that this application only works
while using the GUI. In order to be as user friendly as possible, a GUI based application was needed so that anyone who doesn’t know how to code can access and use this application.
A Project object is created in order to start the application. This project object will create 8 Recording objects. These recording objects will have effects added to them if an effect has been selected from the GUI. Once an effect has been selected, the submit effects button via callback will create the the corresponding effect object in order to adjust the recording object data. The clear effects button has a callback to clear and delete all the effects data and graphs that have been applied. Each of the buttons in the GUI have callbacks to check to see which track has been selected in order to implement its specific function. The save feature uses a helper function  combineData  to add all the tracks together. The import feature uses a helper function  HELPERPLOT in order to correctly plot the imported data to the selected track on the GUI. The volume class was added so that the user can easily access their systems volume without leaving the application. An event listener has been added to the volume slider in order to adjust the system’s volume by changing the master volume slider.
## UML diagram:
    
